{
  "description": "MachineOSConfig describes the configuration for a build process managed by the MCO Compatibility level 4: No compatibility is provided, the API can change at any point for any reason. These capabilities should not be used by applications needing long term support.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      "$ref": "_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    },
    "spec": {
      "description": "spec describes the configuration of the machineosconfig",
      "type": "object",
      "required": [
        "buildInputs",
        "machineConfigPool"
      ],
      "properties": {
        "buildInputs": {
          "description": "buildInputs is where user input options for the build live",
          "type": "object",
          "required": [
            "baseImagePullSecret",
            "imageBuilder",
            "renderedImagePushSecret",
            "renderedImagePushspec"
          ],
          "properties": {
            "baseImagePullSecret": {
              "description": "baseImagePullSecret is the secret used to pull the base image. must live in the openshift-machine-config-operator namespace",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "name is the name of the secret used to push or pull this MachineOSConfig object. this secret must be in the openshift-machine-config-operator namespace.",
                  "type": "string"
                }
              }
            },
            "baseOSExtensionsImagePullspec": {
              "description": "baseOSExtensionsImagePullspec is the base Extensions image used in the build process the MachineOSConfig object will use the in cluster image registry configuration. if you wish to use a mirror or any other settings specific to registries.conf, please specify those in the cluster wide registries.conf. The format of the image pullspec is: host[:port][/namespace]/name@sha256:<digest>",
              "type": "string",
              "maxLength": 447,
              "minLength": 1,
              "x-kubernetes-validations": [
                {
                  "message": "the OCI Image reference must end with a valid '@sha256:<digest>' suffix, where '<digest>' is 64 characters long",
                  "rule": "(self.split('@').size() == 2 && self.split('@')[1].matches('^sha256:[a-f0-9]{64}$'))"
                },
                {
                  "message": "the OCI Image name should follow the host[:port][/namespace]/name format, resembling a valid URL without the scheme",
                  "rule": "(self.split('@')[0].matches('^([a-zA-Z0-9-]+\\\\.)+[a-zA-Z0-9-]+(:[0-9]{2,5})?/([a-zA-Z0-9-_]{0,61}/)?[a-zA-Z0-9-_.]*?$'))"
                }
              ]
            },
            "baseOSImagePullspec": {
              "description": "baseOSImagePullspec is the base OSImage we use to build our custom image. the MachineOSConfig object will use the in cluster image registry configuration. if you wish to use a mirror or any other settings specific to registries.conf, please specify those in the cluster wide registries.conf. The format of the image pullspec is: host[:port][/namespace]/name@sha256:<digest>",
              "type": "string",
              "maxLength": 447,
              "minLength": 1,
              "x-kubernetes-validations": [
                {
                  "message": "the OCI Image reference must end with a valid '@sha256:<digest>' suffix, where '<digest>' is 64 characters long",
                  "rule": "(self.split('@').size() == 2 && self.split('@')[1].matches('^sha256:[a-f0-9]{64}$'))"
                },
                {
                  "message": "the OCI Image name should follow the host[:port][/namespace]/name format, resembling a valid URL without the scheme",
                  "rule": "(self.split('@')[0].matches('^([a-zA-Z0-9-]+\\\\.)+[a-zA-Z0-9-]+(:[0-9]{2,5})?/([a-zA-Z0-9-_]{0,61}/)?[a-zA-Z0-9-_.]*?$'))"
                }
              ]
            },
            "containerFile": {
              "description": "containerFile describes the custom data the user has specified to build into the image. this is also commonly called a Dockerfile and you can treat it as such. The content is the content of your Dockerfile.",
              "type": "array",
              "maxItems": 7,
              "minItems": 0,
              "items": {
                "description": "MachineOSContainerfile contains all custom content the user wants built into the image",
                "type": "object",
                "required": [
                  "content"
                ],
                "properties": {
                  "containerfileArch": {
                    "description": "containerfileArch describes the architecture this containerfile is to be built for this arch is optional. If the user does not specify an architecture, it is assumed that the content can be applied to all architectures, or in a single arch cluster: the only architecture.",
                    "type": "string",
                    "enum": [
                      "arm64",
                      "amd64",
                      "ppc64le",
                      "s390x",
                      "aarch64",
                      "x86_64",
                      "noarch"
                    ]
                  },
                  "content": {
                    "description": "content is the custom content to be built",
                    "type": "string"
                  }
                }
              },
              "x-kubernetes-list-map-keys": [
                "containerfileArch"
              ],
              "x-kubernetes-list-type": "map"
            },
            "imageBuilder": {
              "description": "machineOSImageBuilder describes which image builder will be used in each build triggered by this MachineOSConfig",
              "type": "object",
              "required": [
                "imageBuilderType"
              ],
              "properties": {
                "imageBuilderType": {
                  "description": "imageBuilderType specifies the backend to be used to build the image. Valid options are: PodImageBuilder",
                  "type": "string",
                  "enum": [
                    "PodImageBuilder"
                  ]
                }
              }
            },
            "releaseVersion": {
              "description": "releaseVersion is associated with the base OS Image. This is the version of Openshift that the Base Image is associated with. This field is populated from the machine-config-osimageurl configmap in the openshift-machine-config-operator namespace. It will come in the format: 4.16.0-0.nightly-2024-04-03-065948 or any valid release. The MachineOSBuilder populates this field and validates that this is a valid stream. This is used as a label in the dockerfile that builds the OS image.",
              "type": "string"
            },
            "renderedImagePushSecret": {
              "description": "renderedImagePushSecret is the secret used to connect to a user registry. the final image push and pull secrets should be separate for security concerns. If the final image push secret is somehow exfiltrated, that gives someone the power to push images to the image repository. By comparison, if the final image pull secret gets exfiltrated, that only gives someone to pull images from the image repository. It's basically the principle of least permissions. this push secret will be used only by the MachineConfigController pod to push the image to the final destination. Not all nodes will need to push this image, most of them will only need to pull the image in order to use it.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "name is the name of the secret used to push or pull this MachineOSConfig object. this secret must be in the openshift-machine-config-operator namespace.",
                  "type": "string"
                }
              }
            },
            "renderedImagePushspec": {
              "description": "renderedImagePushspec describes the location of the final image. the MachineOSConfig object will use the in cluster image registry configuration. if you wish to use a mirror or any other settings specific to registries.conf, please specify those in the cluster wide registries.conf. The format of the image pushspec is: host[:port][/namespace]/name:<tag> or svc_name.namespace.svc[:port]/repository/name:<tag>",
              "type": "string",
              "maxLength": 447,
              "minLength": 1,
              "x-kubernetes-validations": [
                {
                  "message": "the OCI Image reference must end with a valid :<tag>, where '<digest>' is 64 characters long and '<tag>' is any valid string  Or it must be a valid .svc followed by a port, repository, image name, and tag.",
                  "rule": "((self.split(':').size() == 2 && self.split(':')[1].matches('^([a-zA-Z0-9-./:])+$')) || self.matches('^[^.]+\\\\.[^.]+\\\\.svc:\\\\d+\\\\/[^\\\\/]+\\\\/[^\\\\/]+:[^\\\\/]+$'))"
                },
                {
                  "message": "the OCI Image name should follow the host[:port][/namespace]/name format, resembling a valid URL without the scheme. Or it must be a valid .svc followed by a port, repository, image name, and tag.",
                  "rule": "((self.split(':').size() == 2 && self.split(':')[0].matches('^([a-zA-Z0-9-]+\\\\.)+[a-zA-Z0-9-]+(:[0-9]{2,5})?/([a-zA-Z0-9-_]{0,61}/)?[a-zA-Z0-9-_.]*?$')) || self.matches('^[^.]+\\\\.[^.]+\\\\.svc:\\\\d+\\\\/[^\\\\/]+\\\\/[^\\\\/]+:[^\\\\/]+$'))"
                }
              ]
            }
          }
        },
        "buildOutputs": {
          "description": "buildOutputs is where user input options for the build live",
          "type": "object",
          "properties": {
            "currentImagePullSecret": {
              "description": "currentImagePullSecret is the secret used to pull the final produced image. must live in the openshift-machine-config-operator namespace the final image push and pull secrets should be separate for security concerns. If the final image push secret is somehow exfiltrated, that gives someone the power to push images to the image repository. By comparison, if the final image pull secret gets exfiltrated, that only gives someone to pull images from the image repository. It's basically the principle of least permissions. this pull secret will be used on all nodes in the pool. These nodes will need to pull the final OS image and boot into it using rpm-ostree or bootc.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "name is the name of the secret used to push or pull this MachineOSConfig object. this secret must be in the openshift-machine-config-operator namespace.",
                  "type": "string"
                }
              }
            }
          }
        },
        "machineConfigPool": {
          "description": "machineConfigPool is the pool which the build is for",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "name of the MachineConfigPool object.",
              "type": "string",
              "maxLength": 253,
              "pattern": "^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$"
            }
          }
        }
      }
    },
    "status": {
      "description": "status describes the status of the machineosconfig",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "conditions are state related conditions for the config.",
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n // other fields }",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            }
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "currentImagePullspec": {
          "description": "currentImagePullspec is the fully qualified image pull spec used by the MCO to pull down the new OSImage. This must include sha256.",
          "type": "string",
          "maxLength": 447,
          "minLength": 1,
          "x-kubernetes-validations": [
            {
              "message": "the OCI Image reference must end with a valid '@sha256:<digest>' suffix, where '<digest>' is 64 characters long",
              "rule": "(self.split('@').size() == 2 && self.split('@')[1].matches('^sha256:[a-f0-9]{64}$'))"
            },
            {
              "message": "the OCI Image name should follow the host[:port][/namespace]/name format, resembling a valid URL without the scheme",
              "rule": "(self.split('@')[0].matches('^([a-zA-Z0-9-]+\\\\.)+[a-zA-Z0-9-]+(:[0-9]{2,5})?/([a-zA-Z0-9-_]{0,61}/)?[a-zA-Z0-9-_.]*?$'))"
            }
          ]
        },
        "observedGeneration": {
          "description": "observedGeneration represents the generation observed by the controller. this field is updated when the user changes the configuration in BuildSettings or the MCP this object is associated with.",
          "type": "integer",
          "format": "int64"
        }
      }
    }
  },
  "x-kubernetes-group-version-kind": [
    {
      "group": "machineconfiguration.openshift.io",
      "kind": "MachineOSConfig",
      "version": "v1alpha1"
    }
  ],
  "$schema": "http://json-schema.org/schema#"
}